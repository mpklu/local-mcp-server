# Discovery System Architecture

The Local MCP Server features an intelligent discovery system that automatically detects, analyzes, and configures tools in a directory-based architecture. This system eliminates manual configuration while providing fine-grained control through a dual-config approach.

## System Overview

### Discovery Pipeline
```
Directory Scan  â†’  Entry Point Detection  â†’  Config Generation  â†’  Compilation  â†’  Server Load
   (tools/)           (run.py/run.sh)        (individual.json)     (tools.json)     (MCP server)
```

### Key Components

| Component | Purpose | Location |
|-----------|---------|----------|
| **ScriptDiscovery** | Core discovery logic | `src/local_mcp/discovery.py` |
| **discover_tools.py** | CLI discovery tool | `server/discover_tools.py` |
| **build_tools.py** | Config compiler | `server/build_tools.py` |
| **Individual Configs** | Per-tool settings | `config/tools/*.json` |
| **Compiled Config** | Server configuration | `config/tools.json` |

## Directory-Based Discovery

### Tool Detection Rules

1. **Directory Requirement**: Each tool must be in its own subdirectory under `tools/`
2. **Entry Point Detection** (in order of priority):
   - `run.py` (Python script with Fire CLI)
   - `run.sh` (Shell script)
   - `run` (Any executable file)
3. **Metadata Extraction**: Analyzes entry points for parameters, descriptions, and dependencies
4. **Dependency Detection**: Reads `requirements.txt` if present

### Example Structure
```
tools/
â”œâ”€â”€ my-python-tool/         # Tool directory
â”‚   â”œâ”€â”€ run.py              # Entry point (Fire CLI)
â”‚   â”œâ”€â”€ processor.py        # Main logic
â”‚   â”œâ”€â”€ requirements.txt    # Dependencies
â”‚   â””â”€â”€ README.md           # Documentation
â”œâ”€â”€ my-shell-tool/          # Another tool
â”‚   â”œâ”€â”€ run.sh              # Shell script entry
â”‚   â””â”€â”€ utils.sh            # Helper scripts
â””â”€â”€ my-binary-tool/         # Binary tool
    â”œâ”€â”€ run                 # Executable wrapper
    â””â”€â”€ my-tool             # Actual binary
```

## Configuration System

### Dual Configuration Architecture

The system maintains two levels of configuration:

#### 1. Individual Tool Configs (`config/tools/*.json`)
- **Purpose**: Per-tool settings managed via web interface
- **Format**: Rich metadata with UI-friendly structure
- **Management**: Created by discovery tool, edited via web interface
- **Persistence**: Permanent storage for user customizations

#### 2. Compiled Config (`config/tools.json`)
- **Purpose**: Optimized configuration consumed by MCP server
- **Format**: Flattened structure for fast server startup
- **Management**: Generated by `build_tools.py` from individual configs
- **Regeneration**: Rebuilt whenever individual configs change

### Configuration Flow
```
Tool Discovery â†’ Individual Config â†’ Web Interface Edit â†’ Compilation â†’ Server Load
     â†“                â†“                    â†“                â†“            â†“
Directory scan    my-tool.json      User modifications   tools.json   MCP server
```

## Discovery Tool Usage

### Command Line Interface

```bash
cd server/

# Generate configs for newly discovered tools
python discover_tools.py

# List all tools and their config status
python discover_tools.py --list

# Force regeneration of all configs (overwrites existing)
python discover_tools.py --force

# Show help and options
python discover_tools.py --help
```

### Discovery Output
```
2025-09-23 11:07:01,299 - __main__ - INFO - Found 5 tools in /path/to/tools
2025-09-23 11:07:01,299 - __main__ - INFO - ðŸ“ Found 5 tools that need individual configs:
2025-09-23 11:07:01,299 - __main__ - INFO -   - file-ops
2025-09-23 11:07:01,299 - __main__ - INFO -   - http-client
2025-09-23 11:07:01,299 - __main__ - INFO -   - demo-features
2025-09-23 11:07:01,299 - __main__ - INFO -   - text-utils
2025-09-23 11:07:01,299 - __main__ - INFO -   - system-info
2025-09-23 11:07:01,299 - __main__ - INFO - âœ… Created 5/5 individual configs
```

### Configuration Generation

**Auto-Generated Fields**:
- `name`: Tool directory name
- `script_path`: Relative path to entry point
- `script_type`: Detected type (python, shell, executable)
- `dependencies`: Parsed from requirements.txt
- `parameters`: Extracted from Fire CLI analysis (Python tools)
- `description`: Extracted from docstrings or defaults

**User-Configurable Fields**:
- `enabled`: Enable/disable tool
- `tags`: Organizational tags
- `requires_confirmation`: Safety setting for destructive operations
- `interactive`: Whether tool requires user interaction
- `examples`: Usage examples for documentation

## Build System

### Compilation Process

```bash
cd server/

# Compile individual configs into server config
python build_tools.py

# Output shows compilation results
2025-09-23 11:07:01,999 - __main__ - INFO - Building tools.json from individual tool configurations...
2025-09-23 11:07:01,999 - __main__ - INFO - Loaded config for tool: system-info
2025-09-23 11:07:01,999 - __main__ - INFO - Loaded config for tool: demo-features
2025-09-23 11:07:01,999 - __main__ - INFO - Loaded config for tool: http-client
2025-09-23 11:07:01,999 - __main__ - INFO - Loaded config for tool: file-ops
2025-09-23 11:07:01,999 - __main__ - INFO - Loaded config for tool: text-utils
2025-09-23 11:07:01,999 - __main__ - INFO - Successfully built tools.json with 5 enabled tools
```

### Build Rules
- **Only enabled tools** are included in compiled config
- **Validation checks** ensure config consistency
- **Dependency resolution** verifies requirements are installable
- **Schema validation** ensures MCP server compatibility

### Manual Build Triggers
- After editing individual configs via web interface
- Before starting MCP server with new tools
- After modifying tool entry points or dependencies
- During development and testing workflows

## API Integration

### Python Discovery API

```python
from local_mcp.discovery import ScriptDiscovery
from local_mcp.config import Config
from pathlib import Path

# Initialize discovery system
tools_dir = Path("tools")
config_dir = Path("config")
config = Config(config_dir)
discovery = ScriptDiscovery(tools_dir, config)

# Discover tools
discovered_tools = discovery.discover_scripts()
print(f"Found {len(discovered_tools)} tools")

# Get tool details
for tool_name, tool_data in discovered_tools.items():
    print(f"Tool: {tool_name}")
    print(f"  Path: {tool_data['script_path']}")
    print(f"  Type: {tool_data['script_type']}")
    print(f"  Dependencies: {tool_data['dependencies']}")
```

### Web Interface Integration

The discovery system integrates seamlessly with the web interface:

- **Auto-refresh**: New tools appear automatically after discovery
- **Configuration editing**: Individual configs editable via forms
- **Dependency management**: One-click dependency installation
- **Status monitoring**: Real-time tool status and health checks
- **Bulk operations**: Mass enable/disable, export/import configs

## Advanced Features

### Custom Discovery Rules

You can extend discovery rules by subclassing `ScriptDiscovery`:

```python
from local_mcp.discovery import ScriptDiscovery

class CustomDiscovery(ScriptDiscovery):
    def _analyze_tool_directory(self, tool_dir: Path) -> Optional[Dict[str, Any]]:
        # Custom analysis logic
        result = super()._analyze_tool_directory(tool_dir)
        
        if result and tool_dir.name.startswith("experimental-"):
            result["requires_confirmation"] = True
            result["tags"] = ["experimental"]
            
        return result
```

### Dependency Management Integration

The discovery system integrates with the dependency manager:

```python
from local_mcp.dependency_manager import IndividualVenvManager

# Discovery triggers dependency analysis
discovery = ScriptDiscovery(tools_dir, config)
dependency_manager = IndividualVenvManager(tools_dir, config)

for tool_name, tool_config in discovered_tools.items():
    if tool_config["dependencies"]:
        dependency_manager.ensure_dependencies(tool_name, tool_config["dependencies"])
```

### Configuration Templates

Discovery supports configuration templates for common tool patterns:

```json
// Template for HTTP client tools
{
  "script_type": "python",
  "requires_confirmation": false,
  "interactive": false,
  "tags": ["http", "api"],
  "default_parameters": {
    "timeout": 30,
    "retries": 3
  }
}
```

## Troubleshooting

### Discovery Issues

**Problem**: Tool not detected
```bash
# Check directory structure
ls -la tools/my-tool/

# Ensure entry point exists and is executable
ls -la tools/my-tool/run.py
chmod +x tools/my-tool/run.py

# Run discovery with verbose output
python discover_tools.py --list
```

**Problem**: Configuration generation fails
```bash
# Check for syntax errors in entry point
python tools/my-tool/run.py --help

# Validate requirements.txt
pip check -r tools/my-tool/requirements.txt

# Check discovery logs
tail -f config/server.log
```

### Build Issues

**Problem**: Compilation fails
```bash
# Validate individual config syntax
python -m json.tool config/tools/my-tool.json

# Check for missing dependencies
python build_tools.py --validate

# Force rebuild
rm config/tools.json
python build_tools.py
```

**Problem**: Config inconsistencies
```bash
# Compare individual vs compiled config
diff <(jq '.["my-tool"]' config/tools.json) \
     <(jq '.script_config' config/tools/my-tool.json)

# Rebuild from scratch
rm -f config/tools/*.json config/tools.json
python discover_tools.py
python build_tools.py
```

### Performance Optimization

**For Large Tool Collections**:
- Use `--force` flag sparingly (only when necessary)
- Enable caching in discovery system for faster subsequent runs
- Use selective discovery for specific tool directories
- Monitor discovery performance with timing logs

**For Development Workflows**:
- Use file watchers to trigger automatic discovery on tool changes
- Implement incremental discovery for modified tools only
- Cache dependency analysis results for faster startup
- Use parallel discovery for large tool collections

## Integration Examples

### CI/CD Pipeline Integration

```yaml
# .github/workflows/tool-discovery.yml
name: Tool Discovery and Validation
on: [push, pull_request]

jobs:
  validate-tools:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.8+'
      - name: Install dependencies
        run: cd server && uv sync
      - name: Discover and validate tools
        run: |
          cd server
          python discover_tools.py --list
          python build_tools.py --validate
          python -m pytest tests/test_discovery.py
```

### Docker Integration

```dockerfile
# Dockerfile with discovery system
FROM python:3.8-slim

# Copy source
COPY . /app
WORKDIR /app/server

# Install dependencies
RUN uv sync

# Run discovery and build
RUN python discover_tools.py && python build_tools.py

# Start server
CMD ["./start_server.sh", "--host", "generic"]
```

### Development Workflow

```bash
#!/bin/bash
# dev-workflow.sh - Development helper script

set -e

echo "ðŸ” Discovering tools..."
cd server && python discover_tools.py

echo "ðŸ”¨ Building configuration..."
python build_tools.py

echo "ðŸ§ª Running tests..."
python -m pytest tests/ -v

echo "ðŸš€ Starting development server..."
cd ../web-interface && ./start_dev.sh
```

This discovery system provides a robust foundation for automatic tool management while maintaining flexibility for custom configurations and advanced use cases.